%code requires{
  #include "../include/ast.hpp"

  #include <cassert>
  #include <fstream>
  
  
  extern FILE *yyin;
  extern const TranslationUnit *g_root; // A way of getting the AST out


  //! This is to fix problems when generating C++
  // We are declaring the functions provided by Flex, so
  // that Bison generated code can call them.
  int yylex(void);
  void yyerror(const char *);


}

// Represents the value associated with any kind of
// AST node.



%token IDENTIFIER CONSTANT STRING_LITERAL SIZEOF SEMICOLON
%token PTR_OP INC_OP DEC_OP LEFT_OP RIGHT_OP LE_OP GE_OP EQ_OP NE_OP
%token AND_OP OR_OP MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN ADD_ASSIGN
%token SUB_ASSIGN LEFT_ASSIGN RIGHT_ASSIGN AND_ASSIGN 
%token XOR_ASSIGN OR_ASSIGN GT LT PLUS MINUS TILDE MULTIPLY MODULO DIVIDE 

%token TYPEDEF EXTERN STATIC AUTO REGISTER
%token CHAR SHORT INT LONG SIGNED UNSIGNED FLOAT DOUBLE CONST VOLATILE VOID
%token STRUCT UNION  ELLIPSIS PREPROCESSOR

%token CASE DEFAULT IF ELSE SWITCH WHILE DO FOR GOTO CONTINUE BREAK RETURN



%start TRANSLATION_UNIT
%%

PRIMARY_EXPRESSION
	: IDENTIFIER
	| CONSTANT
	| STRING_LITERAL
	| '(' EXPRESSION ')'
	;

POSTFIX_EXPRESSION
	: PRIMARY_EXPRESSION
	| POSTFIX_EXPRESSION '[' EXPRESSION ']'
	| POSTFIX_EXPRESSION '(' ')'
	| POSTFIX_EXPRESSION '(' ARGUMENT_EXPRESSION_LIST ')'
	| POSTFIX_EXPRESSION '.' IDENTIFIER
	| POSTFIX_EXPRESSION PTR_OP IDENTIFIER
	| POSTFIX_EXPRESSION INC_OP
	| POSTFIX_EXPRESSION DEC_OP
	;

ARGUMENT_EXPRESSION_LIST
	: ASSIGNMENT_EXPRESSION
	| ARGUMENT_EXPRESSION_LIST ',' ASSIGNMENT_EXPRESSION
	;

UNARY_EXPRESSION
	: POSTFIX_EXPRESSION
	| INC_OP UNARY_EXPRESSION
	| DEC_OP UNARY_EXPRESSION
	| UNARY_OPERATOR CAST_EXPRESSION
	| SIZEOF UNARY_EXPRESSION
	| SIZEOF '(' TYPE_NAME ')'
	;

UNARY_OPERATOR
	: '&'
	| '*'
	| '+'
	| '-'
	| '~'
	| '!'
	;

CAST_EXPRESSION
	: UNARY_EXPRESSION
	| '(' TYPE_NAME ')' CAST_EXPRESSION
	;

MULTIPLICATIVE_EXPRESSION
	: CAST_EXPRESSION
	| MULTIPLICATIVE_EXPRESSION '*' CAST_EXPRESSION
	| MULTIPLICATIVE_EXPRESSION '/' CAST_EXPRESSION
	| MULTIPLICATIVE_EXPRESSION '%' CAST_EXPRESSION
	;

ADDITIVE_EXPRESSION
	: MULTIPLICATIVE_EXPRESSION
	| ADDITIVE_EXPRESSION '+' MULTIPLICATIVE_EXPRESSION
	| ADDITIVE_EXPRESSION '-' MULTIPLICATIVE_EXPRESSION
	;

SHIFT_EXPRESSION
	: ADDITIVE_EXPRESSION
	| SHIFT_EXPRESSION LEFT_OP ADDITIVE_EXPRESSION
	| SHIFT_EXPRESSION RIGHT_OP ADDITIVE_EXPRESSION
	;

RELATIONAL_EXPRESSION
	: SHIFT_EXPRESSION
	| RELATIONAL_EXPRESSION '<' SHIFT_EXPRESSION
	| RELATIONAL_EXPRESSION '>' SHIFT_EXPRESSION
	| RELATIONAL_EXPRESSION LE_OP SHIFT_EXPRESSION
	| RELATIONAL_EXPRESSION GE_OP SHIFT_EXPRESSION
	;

EQUALITY_EXPRESSION
	: RELATIONAL_EXPRESSION
	| EQUALITY_EXPRESSION EQ_OP RELATIONAL_EXPRESSION
	| EQUALITY_EXPRESSION NE_OP RELATIONAL_EXPRESSION
	;

AND_EXPRESSION
	: EQUALITY_EXPRESSION
	| AND_EXPRESSION '&' EQUALITY_EXPRESSION
	;

EXCLUSIVE_OR_EXPRESSION
	: AND_EXPRESSION
	| EXCLUSIVE_OR_EXPRESSION '^' AND_EXPRESSION
	;

INCLUSIVE_OR_EXPRESSION
	: EXCLUSIVE_OR_EXPRESSION
	| INCLUSIVE_OR_EXPRESSION '|' EXCLUSIVE_OR_EXPRESSION
	;

LOGICAL_AND_EXPRESSION
	: INCLUSIVE_OR_EXPRESSION
	| LOGICAL_AND_EXPRESSION AND_OP INCLUSIVE_OR_EXPRESSION
	;

LOGICAL_OR_EXPRESSION
	: LOGICAL_AND_EXPRESSION
	| LOGICAL_OR_EXPRESSION OR_OP LOGICAL_AND_EXPRESSION
	;

CONDITIONAL_EXPRESSION
	: LOGICAL_OR_EXPRESSION
	| LOGICAL_OR_EXPRESSION '?' EXPRESSION ':' CONDITIONAL_EXPRESSION
	;

ASSIGNMENT_EXPRESSION
	: CONDITIONAL_EXPRESSION
	| UNARY_EXPRESSION ASSIGNMENT_OPERATOR ASSIGNMENT_EXPRESSION
	;

ASSIGNMENT_OPERATOR
	: '='
	| MUL_ASSIGN
	| DIV_ASSIGN
	| MOD_ASSIGN
	| ADD_ASSIGN
	| SUB_ASSIGN
	| LEFT_ASSIGN
	| RIGHT_ASSIGN
	| AND_ASSIGN
	| XOR_ASSIGN
	| OR_ASSIGN
	;

EXPRESSION
	: ASSIGNMENT_EXPRESSION
	| EXPRESSION ',' ASSIGNMENT_EXPRESSION
	;

CONSTANT_EXPRESSION
	: CONDITIONAL_EXPRESSION
	;

DECLARATION
	: DECLARATION_SPECIFIERS ';'
	| DECLARATION_SPECIFIERS INIT_DECLARATOR_LIST ';'
	;

DECLARATION_SPECIFIERS
	: STORAGE_CLASS_SPECIFIER
	| STORAGE_CLASS_SPECIFIER DECLARATION_SPECIFIERS
	| TYPE_SPECIFIER
	| TYPE_SPECIFIER DECLARATION_SPECIFIERS
	| TYPE_QUALIFIER
	| TYPE_QUALIFIER DECLARATION_SPECIFIERS
	;

INIT_DECLARATOR_LIST
	: INIT_DECLARATOR
	| INIT_DECLARATOR_LIST ',' INIT_DECLARATOR
	;

INIT_DECLARATOR
	: DECLARATOR
	| DECLARATOR '=' INITIALIZER
	;

STORAGE_CLASS_SPECIFIER
	: TYPEDEF
	| EXTERN
	| STATIC
	| AUTO
	| REGISTER
	;

TYPE_SPECIFIER
	: VOID
	| CHAR
	| SHORT
	| INT
	| LONG
	| FLOAT
	| DOUBLE
	| SIGNED
	| UNSIGNED
	//| STRUCT_OR_UNION_SPECIFIER
	//| ENUM_SPECIFIER
	//| TYPE_NAME
	;
/*
STRUCT_OR_UNION_SPECIFIER
	: STRUCT_OR_UNION IDENTIFIER '{' STRUCT_DECLARATION_LIST '}'
	| STRUCT_OR_UNION '{' STRUCT_DECLARATION_LIST '}'
	| STRUCT_OR_UNION IDENTIFIER
	;

STRUCT_OR_UNION
	: STRUCT
	| UNION
	;

STRUCT_DECLARATION_LIST
	: STRUCT_DECLARATION
	| STRUCT_DECLARATION_LIST STRUCT_DECLARATION
	;

STRUCT_DECLARATION
	: SPECIFIER_QUALIFIER_LIST STRUCT_DECLARATOR_LIST ';'
	;

SPECIFIER_QUALIFIER_LIST
	: TYPE_SPECIFIER SPECIFIER_QUALIFIER_LIST
	| TYPE_SPECIFIER
	| TYPE_QUALIFIER SPECIFIER_QUALIFIER_LIST
	| TYPE_QUALIFIER
	;

STRUCT_DECLARATOR_LIST
	: STRUCT_DECLARATOR
	| STRUCT_DECLARATOR_LIST ',' STRUCT_DECLARATOR
	;

STRUCT_DECLARATOR
	: DECLARATOR
	| ':' CONSTANT_EXPRESSION
	| DECLARATOR ':' CONSTANT_EXPRESSION
	;
/*
ENUM_SPECIFIER
	: ENUM '{' ENUMERATOR_LIST '}'
	| ENUM IDENTIFIER '{' ENUMERATOR_LIST '}'
	| ENUM IDENTIFIER
	;

ENUMERATOR_LIST
	: ENUMERATOR
	| ENUMERATOR_LIST ',' ENUMERATOR
	;

//ENUMERATOR
//	: IDENTIFIER
//	| IDENTIFIER '=' CONSTANT_EXPRESSION
//	;

TYPE_QUALIFIER
	: CONST
	| VOLATILE
	;
*/

DECLARATOR
	: POINTER DIRECT_DECLARATOR
	| DIRECT_DECLARATOR
	;

DIRECT_DECLARATOR
	: IDENTIFIER
	| '(' DECLARATOR ')'
	| DIRECT_DECLARATOR '[' CONSTANT_EXPRESSION ']'
	| DIRECT_DECLARATOR '[' ']'
	| DIRECT_DECLARATOR '(' PARAMETER_TYPE_LIST ')'
	| DIRECT_DECLARATOR '(' IDENTIFIER_LIST ')'
	| DIRECT_DECLARATOR '(' ')'
	;

POINTER
	: '*'
	| '*' TYPE_QUALIFIER_LIST
	| '*' POINTER
	| '*' TYPE_QUALIFIER_LIST POINTER
	;

TYPE_QUALIFIER_LIST
	: TYPE_QUALIFIER
	| TYPE_QUALIFIER_LIST TYPE_QUALIFIER
	;


PARAMETER_TYPE_LIST
	: PARAMETER_LIST
	| PARAMETER_LIST ',' ELLIPSIS
	;

PARAMETER_LIST
	: PARAMETER_DECLARATION
	| PARAMETER_LIST ',' PARAMETER_DECLARATION
	;

PARAMETER_DECLARATION
	: DECLARATION_SPECIFIERS DECLARATOR
	| DECLARATION_SPECIFIERS ABSTRACT_DECLARATOR
	| DECLARATION_SPECIFIERS
	;

IDENTIFIER_LIST
	: IDENTIFIER
	| IDENTIFIER_LIST ',' IDENTIFIER
	;

TYPE_NAME
	: SPECIFIER_QUALIFIER_LIST
	| SPECIFIER_QUALIFIER_LIST ABSTRACT_DECLARATOR
	;

ABSTRACT_DECLARATOR
	: POINTER
	| DIRECT_ABSTRACT_DECLARATOR
	| POINTER DIRECT_ABSTRACT_DECLARATOR
	;

DIRECT_ABSTRACT_DECLARATOR
	: '(' ABSTRACT_DECLARATOR ')'
	| '[' ']'
	| '[' CONSTANT_EXPRESSION ']'
	| DIRECT_ABSTRACT_DECLARATOR '[' ']'
	| DIRECT_ABSTRACT_DECLARATOR '[' CONSTANT_EXPRESSION ']'
	| '(' ')'
	| '(' PARAMETER_TYPE_LIST ')'
	| DIRECT_ABSTRACT_DECLARATOR '(' ')'
	| DIRECT_ABSTRACT_DECLARATOR '(' PARAMETER_TYPE_LIST ')'
	;

INITIALIZER
	: ASSIGNMENT_EXPRESSION
	| '{' INITIALIZER_LIST '}'
	| '{' INITIALIZER_LIST ',' '}'
	;

INITIALIZER_LIST
	: INITIALIZER
	| INITIALIZER_LIST ',' INITIALIZER
	;

STATEMENT
	: LABELED_STATEMENT
	| COMPOUND_STATEMENT
	| EXPRESSION_STATEMENT
	| SELECTION_STATEMENT
	| ITERATION_STATEMENT
	| JUMP_STATEMENT
	;

LABELED_STATEMENT
	: IDENTIFIER ':' STATEMENT
	| CASE CONSTANT_EXPRESSION ':' STATEMENT
	| DEFAULT ':' STATEMENT
	;

COMPOUND_STATEMENT
	: '{' '}'
	| '{' STATEMENT_LIST '}'
	| '{' DECLARATION_LIST '}'
	| '{' DECLARATION_LIST STATEMENT_LIST '}'
	;

DECLARATION_LIST
	: DECLARATION
	| DECLARATION_LIST DECLARATION
	;

STATEMENT_LIST
	: STATEMENT
	| STATEMENT_LIST STATEMENT
	;

EXPRESSION_STATEMENT
	: ';'
	| EXPRESSION ';'
	;

SELECTION_STATEMENT
	: IF '(' EXPRESSION ')' STATEMENT
	| IF '(' EXPRESSION ')' STATEMENT ELSE STATEMENT
	| SWITCH '(' EXPRESSION ')' STATEMENT
	;

ITERATION_STATEMENT
	: WHILE '(' EXPRESSION ')' STATEMENT
	| DO STATEMENT WHILE '(' EXPRESSION ')' ';'
	| FOR '(' EXPRESSION_STATEMENT EXPRESSION_STATEMENT ')' STATEMENT
	| FOR '(' EXPRESSION_STATEMENT EXPRESSION_STATEMENT EXPRESSION ')' STATEMENT
	;

JUMP_STATEMENT
	: GOTO IDENTIFIER ';'
	| CONTINUE ';'
	| BREAK ';'
	| RETURN ';'
	| RETURN EXPRESSION ';'
	;

TRANSLATION_UNIT
	: EXTERNAL_DECLARATION				
	| TRANSLATION_UNIT EXTERNAL_DECLARATION		
	;

EXTERNAL_DECLARATION
	: FUNCTION_DEFINITION
	| DECLARATION
	;

FUNCTION_DEFINITION
	: DECLARATION_SPECIFIERS DECLARATOR DECLARATION_LIST COMPOUND_STATEMENT
	| DECLARATION_SPECIFIERS DECLARATOR COMPOUND_STATEMENT
	| DECLARATOR DECLARATION_LIST COMPOUND_STATEMENT
	| DECLARATOR COMPOUND_STATEMENT
	;

%%

const TranslationUnit *g_root; // Definition of variable (to match declaration earlier)



const TranslationUnit* parseAST(char* x, char* y){
  g_root=0;
  yyin = fopen(x, "r");
  if(yyin) { 
	  yyparse();
  }
  fclose(yyin);
	
  return g_root;
}
